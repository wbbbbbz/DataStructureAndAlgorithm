# 第 4 章 堆和堆排序

> ## 参考[玩转数据结构 从入门到进阶-慕课网实战 第 8 章 优先队列和堆](notes/datastructure/Chapter8.md)

- 系统级别的排序很少使用堆排序，因为效率没有快速排序或者归并排序好
  - 更多使用于动态数据的维护
- 原地堆排序
  - 最大堆底层可以是一个数组
  - 这样的话每一次数组第一个元素是最大值，将该最大值交换到数组最后，然后再维护前面的数组部分(SiftDown)

|                          | 平均时间复杂度 | 原地排序 | 额外空间 | 稳定排序 |
| :----------------------: | :------------: | :------: | -------- | -------- |
| 插入排序(Insertion Sort) |     O(n^2)     |    〇    | O(1)     | 〇       |
|   归并排序(Merge Sort)   |    O(nlogn)    |    x     | O(n)     | 〇       |
|   快速排序(Quick Sort)   |    O(nlogn)    |    〇    | O(logn)  | x        |
|    堆排序(Heap Sort)     |    O(nlogn)    |    〇    | O(1)     | x        |

- 稳定排序：对于相等的元素，在排序后，原来靠前的元素依然靠前
  - 可以通过自定义比较函数，让排序算法不存在稳定性的问题
  - 一般要稳定的排序，使用归并排序
- 理论上完美的排序算法是存在的，但是现在还没有被发现

- 堆可以辅助完成多路归并排序，也就是 merge sort 的时候分割成多个子数组

  - 所有子数组都放入一个最小堆中
  - d 路归并排序，性能平衡
  - n 路排序就是堆排序

- 课后深入
  - 不用 swap，使用赋值
  - 动态调整堆
  - 最大最小队列
    - 可以一个数据结构中放最大堆和最小堆
