# 第 9 章 最短路径

- 最短路径问题 Shortest Path

  - 路径规划，网络路径，工作任务规划

- 无权图的广度优先遍历会形成一棵起点到所有点的最短路径树(Shortest Path Tree)

  - 也是一棵生成树
  - 解决了单源最短路径(Single Source Shortest Path)
    - 一个点到其他所有点的最短路径

- 无权图和有权图的区别

  - 有权图无法直接确认一条路径是最短路径
  - 需要松弛操作(Relaxtion)
    - 更短路径看似绕路了(权重小，节点多)
    - 每一个节点都要确认一下绕和不绕的路径哪一个更短

- dijkstra 单源最短路径算法

  - 前提：图中不能有负权边
    - 基本不存在负权边
    - 这种问题需要代价，时间复杂度要提升，但是日常生活中比较特殊
  - 复杂度 O(Elog(V))，使用最小索引堆
    - 从原点能抵达的所有顶点的权重记录
    - 其中最小权重的顶点一定就是最短路径（因为图中不能有负权边）
    - 将这个顶点设为新的节点，进行 Relaxation，更新其他节点的最短路径
    - 然后重复上述两个步骤
  - 也可以使用自带的优先队列，把顶点号和对应的最小距离打包在一起
    - 更新顶点的时候放进去重复的无所谓，因为最终取出来的是某个顶点的最小值。同时取出来的时候检查一下，如果已经遍历过就没必要访问了
    - 最多存放的顶点数也就是E，每一条边都存储
      - 所以是ElogE
  - 既要找到最小的节点，又要不断更新，所以 IndexMinHeap
    - 每一次更新和插入都是 logV，然后 E 个边都要操作，所以 ElogV
  - 初始化dis数组，里面都是最大值。存储的是到该节点的当前可能最短距离
    - 每一步确定一个边(未确定部分中最小的那个节点，到那个节点的边一定是最短边)
    - 取出新确定的点，对所有点进行一次更新
    - 若dis[a]最小，那么就是0到a的最短路径长度
      - dis[b] = min(dis[b], dis[a] + ab)
  - 如果只关注某个终点的最短路径，那么就可以提前中止循环
  - 如果求所有点对的最短路径，就运行V次即可

- 处理负权边

  - 拥有负权环的图(每经过一次环路径都会缩小)，没有最短路径
  - 两个节点之间也可能有负权环！
  - 默认有向图，如果无向图的话一定会形成负权环
  - Bellman-Ford也能处理无向图，但是要求无向图一定不能有负权边
    - 既然如此还不如直接用dijkstra算法
    - 无向图可以认为是特殊的有向图

- Bellman-Ford 单源最短路径算法

  - 前提：图中不能有负权环
  - 有负权环的时候，虽然无法找到最短路径，但是可以判断有负权环
  - O(EV)
  - 对所有边进行一次松弛操作，则求出了到所有点，经过的边数最多为+1的最短路径
    - 每一次经过的边数最多+1
    - 每一次松弛，每一次允许多走一条边
    - 重复V-1次则理论上求出最多为V-1的最短路
    - 整个图中最短路径最多只可能是V-1
  - 如果一个图没有负权环，从一点到另外一点的最短路径，最多经过所有的 V 个顶点，有 V-1 条边
  - 否则，存在顶点经过了两次，一定存在负权环
  - 类似 dijkstra，但是对所有节点都要进行松弛操作
  - 对一个点的一次松弛操作，就是找到经过这个点的另外一条路径，多一条边，权值更小
  - 如果一个图没有负权环，从一点到另外一点的最短路径，最多经过所有的 V 个顶点，有 V-1 条边
  - 对所有的点进行 V-1 次松弛操作，理论上就找到了从原点到其他所有点的最短路径
  - 如果还可以继续松弛，那么原图中有负权环
  - 如果只关注某个终点的最短路径，也不能提前中止循环
  - 实际上每一次有很多松弛操作是浪费的，因为很多顶点可能还无法到达，但是需要进行判断

- 课后
  - 一般 distTo[i]初始化为正无穷，或者非常大的数，这样如果该节点没访问过的话 distTo 一定没有更新，小于路径
  - Bellman-Ford 算法优化
    - 很多情况下优化显著
    - SPFA(Shortest Path Fast Algorithm)
      - queue-based bellman-ford 算法
      - 避免了空转的松弛操作
  - 有向无环图(DAG)
    - 实际生活中应用很多
    - 因为无向图任意两个节点就构成环
    - 使用拓扑排序求单源最短路径是 O(V+E)
  - 所有对最短路径算法，可以计算任意顶点间的最短路径
    - 运行 V 遍的单源最短路径算法也行
    - 运行 Floyed 算法，处理无负权环的图，O(V^3)
      - 动态规划
  - 最长路径算法
    - 不能有正权环
    - 广度优先可以找最短路径，但是最长路径是指数级难度
    - 对于有权图不能使用 Dijkstra 求最长路径
    - 可以使用 Bellman-Ford 算法，把所有权换成负数
    - 拓扑排序和 Floyed 是可能的
