# 第 9 章 最短路径

- 最短路径问题 Shortest Path

  - 路径规划，网络路径，工作任务规划

- 无权图的广度优先遍历会形成一棵起点到所有点的最短路径树(Shortest Path Tree)

  - 也是一棵生成树
  - 解决了单源最短路径(Single Source Shortest Path)
    - 一个点到其他所有点的最短路径

- 无权图和有权图的区别

  - 有权图无法直接确认一条路径是最短路径
  - 需要松弛操作(Relaxtion)
    - 更短路径看似绕路了(权重小，节点多)
    - 每一个节点都要确认一下绕和不绕的路径哪一个更短

- dijkstra 单源最短路径算法

  - 前提：图中不能有负权边
    - 基本不存在负权边
    - 这种问题需要代价，时间复杂度要提升，但是日常生活中比较特殊
  - 复杂度 O(Elog(V))，使用最小索引堆
    - 从原点能抵达的所有顶点的权重记录
    - 其中最小权重的顶点一定就是最短路径（因为图中不能有负权边）
    - 将这个顶点设为新的节点，进行 Relaxation，更新其他节点的最短路径
    - 然后重复上述两个步骤
  - 既要找到最小的节点，又要不断更新，所以 IndexMinHeap
    - 每一次更新和插入都是 logV，然后 E 个边都要操作，所以 ElogV

- 处理负权边

  - 拥有负权环的图(每经过一次环路径都会缩小)，没有最短路径
  - 两个节点之间也可能有负权环！
  - 默认有向图，如果无向图的话一定会形成负权环

- Bellman-Ford 单源最短路径算法

  - 前提：图中不能有负权环
  - 有负权环的时候，虽然无法找到最短路径，但是可以判断有负权环
  - O(EV)
  - 如果一个图没有负权环，从一点到另外一点的最短路径，最多经过所有的 V 个顶点，有 V-1 条边
  - 否则，存在顶点经过了两次，一定存在负权环
  - 类似 dijkstra，但是对所有节点都要进行松弛操作
  - 对一个点的一次松弛操作，就是找到经过这个点的另外一条路径，多一条边，权值更小
  - 如果一个图没有负权环，从一点到另外一点的最短路径，最多经过所有的 V 个顶点，有 V-1 条边
  - 对所有的点进行 V-1 次松弛操作，理论上就找到了从原点到其他所有点的最短路径
  - 如果还可以继续松弛，那么原图中有负权环

- 课后
  - 一般 distTo[i]初始化为正无穷，或者非常大的数，这样如果该节点没访问过的话 distTo 一定没有更新，小于路径
  - Bellman-Ford 算法优化
    - queue-based bellman-ford 算法
    - 很多情况下优化显著
  - 有向无环图(DAG)
    - 实际生活中应用很多
    - 因为无向图任意两个节点就构成环
    - 使用拓扑排序求单源最短路径是 O(V+E)
  - 所有对最短路径算法，可以计算任意顶点间的最短路径
    - 运行 V 遍的单源最短路径算法也行
    - 运行 Floyed 算法，处理无负权环的图，O(V^3)
      - 动态规划
  - 最长路径算法
    - 不能有正权环
    - 广度优先可以找最短路径，但是最长路径是指数级难度
    - 对于有权图不能使用 Dijkstra 求最长路径
    - 可以使用 Bellman-Ford 算法，把所有权换成负数
    - 拓扑排序和 Floyed 是可能的
