# 第 11 章 最短路径算法

- Floyed算法
  - 所有点对最短路径
  - Floyed-Warshall
  - Roy-Floyed
  - Roy-Warshall

- 求出所有点对的最短路径，就可以求出图的直径
  - 所有点对最短路径中的最大值就是图的直径

- 基于Dijkstra是O(VElogE)，不能包含负权边。不包含负权边的时候直接使用Dijkstra算法即可
- 基于Bellman-Ford：O(V\*V\*E)，可以包含负权边，检测负权环

- Floyed：O(V\*V\*V)，可以包含负权边，检测负权环
  
- 因为是求所有点对，所以不考虑原点
  - 跟松弛操作想法类似，只不过考虑的时候不是考虑一条边，而是直接考虑到达每一个顶点的最小路径(即经过多条边的可能)
  - if (dis[v][b] + dis[b][a] < dis[v][a]) dis[v][a] = dis[v][b] + dis[b][a]
    - dis代表最短路径距离
  - 初始，如果v-w有边，则dis[v][w] = vw; dis[v][v] = 0
    - 其他边就是正无穷
  - 内层v, w循环是用于计算v-w之间的最短路径
    - 外层嵌套t是用于尝试v-w经过其他所有可能的点，也就是绕道点的循环
    - v-w经过t有没有最短路径
  - 检测负权环
    - 遍历完毕后，如果存在负权环，那么就会出现dis[v][v]<0
    - 就说明负权环。所以遍历完毕后看看二维数组的对角线即可
```java
for(int t = 0; t < V; t++)   // 每轮循环求解出中间经过[0.....t]这些点的最短路径，一次循环多考虑一个点
    for(int v = 0; v < V; v ++)    // 起始点v
        for(int w = 0; w < V; w++)  // 终止点w
            if (dis[v][t] + dis[t][w] < dis[v][w])
                dis[v][w] = dis[v][t] + dis[t][w]
```


- 动态规划
  - Dijkstra定义了dis[v]状态。当前找到的原点到v的最短距离
    - 贪心算法
  - Bellman-Ford定义了dis[v]状态。当前找到的原点到v的最短距离，并且经过不超过V-1条边的最短距离
  - Floyed定义了dis[v][w]状态。当前找到的v到w的最短距离，内含包括v->w绕道0，1，2...点

- 最长路径？NP问题，指数算法