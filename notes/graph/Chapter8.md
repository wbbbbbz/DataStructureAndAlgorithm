# 第 8 章 桥，割点和图的遍历树

- 无向图
  - 删除一条边的话，整个图联通分量数量变化，则这条边成为桥(Bridge)
  - 意味着图中最脆弱的关系
- 桥的应用
  - 交通系统，社交网络
- 一个图中可以有多条桥
  - 树的所有边都是桥
  - 树是所有顶点联通的图，并且边数是最小的
- 寻找桥的算法使用DFS可以解决，但是有一定难度，记录的信息更“多元”
- 面试中不会涉及
- 桥和环有关系，但是和判断是否有环不同，因为桥是一条边的属性
  - 需要遍历每一条边
- 如何判断v-w是不是桥
  - 看w能否从另外一条路回到v或者v*之前*的顶点
  - 对于每一个顶点需要记录DFS的顺序！比如ord数组
  - 还要记录每一个顶点能够到达的最小ord,比如low数组（可以到的的别的顶点中的最小ord）
  - 如果通过w可以到达和v一样的ord，或者比v的ord还小的节点，那么就不是桥
  - 一开始到达节点的时候，low要设置为自身，因为还没有找到别的路
  - 不走直接的回头路，所以递归的时候需要parent参数
  - 如果w的ord小于v的ord，那么lowv就可以更新了！
  - 递归退回的时候low还要进行更新
    - *如果退回之后，low比父亲节点的ord还要大的话，说明通过这条边无法到达比父亲节点，或者祖先节点，所以这个边就是桥！*

- 寻桥不能使用DFS，只能用BFS
- BFS是最短路径

- BFS遍历树和DFS遍历树
- 生成的树不能有环
- 也就是遍历树是把所有节点连接在一起，但是有一些边对应的顶点如果已经遍历了的化，就计入树中
  - 遍历树上的边是前向边，不在遍历树上的边是回向边
- DFS的特殊性质是后向边可以指向自己的祖先节点
  - 就是利用了这个节点所以才找到了桥
- BFS没有这个特性
  - 因为BFS是层序遍历，所以非遍历树上的边不是回向边(因为不会往回指)，应该叫横叉边，不会指向祖先节点


- 割点(Cut)
  - 对于无向图，如果删除了一个顶点(顶点邻边也删除)，整个图联通分量数量变化，则这个顶点称为割点(Cut Points/Articulation Points)
  - 图中最脆弱的点
  - 桥也叫做割边(Cut Edges)
  - 和桥的逻辑非常相似
    - 桥是必须loww>ordv
    - 但是割边是loww>=ordv就行(子节点的low比自己的ord值大于等于)
    - 代表的是通过子节点，能达到的最小ord点是自己，但是如果删掉了自身节点的话，一定无法回去比它还要小ord的点
    - 特殊情况是根节点问题
      - 根节点的话别的点的low一定>=自己的ord
      - 所以根节点需要特殊判断
      - 如果有一个以上的孩子，那么根节点是割点
      - 这里的孩子是指dfs遍历树中的孩子，不是邻边！因为不同的邻边有可能是联通的

```java
int child = 0;
for (Integer w : G.adj(v)) {
    if (!visited[w]) {
        dfs(w, v);
        // 遍历之后需要立刻更新
        low[v] = Math.min(low[w], low[v]);
        // 非根节点的判断
        // 有可能出现重复，当一个节点有多个DFS遍历树上的子节点时，可能出现重复。此时可以去重hashSet
        if (v != s && low[w] >= ord[v])
            cutPoints.add(v);
        // 根节点的判断
        child++;
        if (v == s && child > 1) {
            cutPoints.add(v);
        }
    } 
    // 即使访问过了，只要不是父节点，也要进行low的更新
    else if (w != s) {
        low[v] = Math.min(low[w], low[v]);
    }
}
```

