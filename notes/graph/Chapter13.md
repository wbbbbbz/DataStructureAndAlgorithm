# 第 13 章 有向图算法

- 有向图
  - 社交网络: 关注
  - 互联网连接
  - 程序模块的引用
  - 任务调度
  - 学习计划
  - 食物链
  - 论文引用

- 无向图是特殊的有向图
  - 两条有向边

- 有向图中不存在一些问题
  - floodfill，不会区分有无方向，只有有无相连
  - 最小生成树，连接所有点
  - 桥和割点
  - 二分图检测

- 有些问题在有向图和无向图是一样的
  - DFS遍历(因为有向图中不会存对应的边)
  - BFS遍历
  - Dijkstra
  - BellmanFord
  - Floyd
  - 哈密尔顿回路(因为是回溯，所以不受影响)

- 有向图和无向图中不一样的算法
  - 有向图的环检测
    - 不能直接使用无向图的环检测
    - 已经遍历过不代表形成环，因为可能回不到原路上
    - 解决方法：添加一个遍历的当前路径
    - 无向图中从0->1再从1->0不是合法的环，但是有向图中是有效的环！
    - 所以判断的时候不用判断w != parent!

- 确保有向图无环
  - 程序模块的引用
  - 任务调度
  - 学习计划

- 因为有向无环图非常重要，所以被成为DAG(Directed Acyclic Graph)

- 有向图的度是不一样的！
  - 被指向的边和指出去的边是不一样的
  - 所以需要分出入度(indegree)和出度(outdegree)
  - 入度是进入该点的度，出度是从该点出去的度
  - 导致欧拉回路发生很大的变化，因为欧拉回路是依赖于度数的判断的！

- 有向图存在欧拉回路的充分必要条件
  - 每个点的入度等于出度
  - 寻找是类似的
    - 判断环是通过v.outdegree == 0
    - 最后得到的结果需要逆序(有向图的顺序是很重要的)

- 有向图存在欧拉路径的充分必要条件
  - 除了两个点，其余每个点的入度等于出度
  - 剩余两个点中，一个入度比出度大一
  - 一个出度比入度大一

- 只在有向图中考察的算法
  - 拓扑排序。找到一个顺序保证到达节点时，所有前置节点都已经访问过了
  - 重要的是入度
    - 一开始寻找入度为0的点，进入顺序之后，相当于这个点已经不需要了。并且该点的所有边也可以删掉了
    - 然后重复上面的步骤
  - 实际实装的时候不用删点，只需要对对应的点的入度进行更新就好
  - 可以使用队列记录当前入度为0的顶点(还未处理的)
    - 因为会有同时入度为0的顶点出现，只要入度值变成0，就进入队列
  - 所以拓扑排序的顺序不是唯一的，也有可能无解(比如存在环的时候)
    - 拓扑排序可以用于有向图的环检测
    - 最终检测环的时候可以比较输出的结果数和顶点数是否相等
  - 只有DAG才可以进行拓扑排序
    - 不仅可以排序，还能检测环。也就是拓扑排序如果无解，那么就不是DAG
  - O(V+E)，每一个顶点每一个边都遍历
  
- 拓扑排序的另一个算法
  - 深度优先后序遍历
    - 对于一个节点，遍历完其所有相邻接点之后，再遍历它自身
  - 深度优先后序遍历和拓扑排序是相反关系
    - 因为深度优先遍历中后续的节点一定出现在前面
    - 所以逆过来的话前置节点一定都在前面
  - 但是无法检测环，所以必须保证图一定是DAG
    - 或者必须先环检测
  - O(V+E)

- 有向图的强连通分量
  - 有向图中所有节点看起来都是连接的，但不一定能到达
  - 在一个强连通分量中，任何两点都可达
  - 每一个强连通分量中所有的点都可达，但是不同分量之间不能互相抵达
    - 强连通分量可以看作是一个点，这样一来可以归约成一个新的图
    - 该图中所有强连通分量都看作一个点
    - 每一个强连通分量之间边数可能超过一条
    - 新的图一定是DAG
  - 求有向图中的强连通分量，可以看作求每一个强连通分量内包含哪些点，并且总共有多少个
    - 先dfs遍历出度为0的强连通分量，标记上visited，这样遍历结果一定是该强连通分量中所有的点，然后求下一个节点
    - 顺序是新的图的拓扑排序的逆序，然后进行分别的dfs
    - 所以问题是能否从一开始的图中找到出度为0的强连通分量？

- Kosaraju算法
  - 把原来的图的每一条边反过来(反图)！那么原来出度为0的节点就会变成入度为0的节点，也就是拓扑排序的起点！
  - 如果一个强连通分量能够到一点，则翻转这张图后，进行后序遍历，这一点一定相较强连通分量中的点后出现
    - 则*反转*这张图后，对于*后序遍历的逆*，这一点一定出现在这个强连通分量中的点之前
  - 原图反转之后，后序遍历的顺序一定是每一个强连通分量的拓扑排序的逆
    - 然后通过这个拓扑排序顺序，进行dfs标记，就可以得到强连通分量
  - O(V+E)
  