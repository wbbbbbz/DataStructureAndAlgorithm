# 第 9 章 哈密尔顿回路和状态压缩

- 回路和路径时分隔开的
  - 路径的起点与终点时不一样的，回路的起点和终点时一样的

- 哈密尔顿回路和路径算法基本一样
  - 回溯优化

- 哈密尔顿回路
  - 从一个点出发，沿着边行走，经过每个顶点恰好一次，之后回到出发点
  - 判断是否存在，并且求出回路
  - 数学上找不到充分必要条件
- 旅行推销员问题(Travelling Salesman Problem, TSP)
  - 最短的带权图，完全图的哈密尔顿回路问题

- NP难问题
- 暴力求解
  - 生成全排列，然后验证是否哈密尔顿问题
  - 但是使用回溯会比全排列性能稍微好一点，因为全排列中有一些解根本不可能
  - 尝试了0->1->2，发现不行的话要回溯到0->1，然后再测试别的，这个时候需要维护visited！
  - 只从一个顶点开始回溯就行，因为如果从一个顶点开始无解，那么哈密尔顿回路一定不存在
  - O(n!)最坏情况
  - 递归返回是否存在哈密尔顿回路
    - 最终判断时如果回到了根节点并且全部访问过了，那么就是true
  - 小优化，最终判断所有节点访问过了没有，可以传入left参数代表还剩多少个顶点没有访问
    - 该参数随着visited的更新一起更新
    - 如果使用值的传递，那么不需要left++
    - left--处可以直接判断left==0？

- 哈密尔顿路径和回路不一样，因为起始点非常重要。
  - 需要传入一个起始点参数
  - 终止点可以和起始点不一样！
  - LeetCode 980
    - 可以根据题目给出的数据规模大概推测使用什么复杂度的算法
  - 哈密尔顿路径可以求所有解，但是需要注意visited的复原，因为要保证回溯可能！
    - 只要有return，就要注意visited的复原！
  
- 状态压缩
  - 二维坐标用一个数字表示
  - 两个桶的水量用一个两位数表示
  - 比如visited数组，0true, 1false, 2true, 3false -> 0b0101
    - 但是整型是32位，取出符号位只有31位，图的节点一定要是31个以内。
    - 看第0位是否是1：0b0101 & 0b0001   - > 5 & 1 == 0?    1 = 2^0
    - 看第1位是否是1：0b0101 & 0b0010   - > 5 & 2 == 0?    2 = 2^1
    - visited & (2^i) == 0?
    - visited & (1<<i) == 0?
    - 赋值: 将第1位设为1：0b0101 + 0b0010
    - visited +- (1<<i)
  - 并且visited可以压缩进入递归过程，当作参数也行！
  - 位运算
    - Java中&的有限度太低，所以使用的时候一定要加括号！
    - 只要有位运算，直接使用括号！
  - 状态压缩是为了记忆化搜索！进一步优化

- 记忆化搜索
  - 如果在中间某一个点已经是失败了的话，那么它之后的顶点寻找都是没必要的！
  - 具体体现在传入递归的参数是完全一样的
  - 开拓一个memo数组，memo[1<<G.V()][G.V()]
    - 第一维是visited的状态(每一个顶点都有两种可能)，第二维是顶点的可能数
  - 每一次搜索之前，先查看memo[visited][v]之前是否计算过，如果计算过，直接返回之前计算的结果
  - 否则，计算并将结果存在memo[visited][v]中
  - 经过优化后，最坏情况是O(n\*2^n)，因为这个数组最大的可能性就是n\*2^n
  - 但是实际上回溯也一般达不到O(n!)
  - 回溯和记忆化搜索的优劣是取决于数据的！并且记忆化搜索非常占用内存，实际工程中内存中的读取，更新也是有一定消耗的。
  - 如果有大量的重复搜索的话用记忆化搜索是更好一点
  - 计入memo的时候visited需要清空恢复一下！visited-=1<<v

- 回溯算法和记忆化搜索有时不一定会使效率提高