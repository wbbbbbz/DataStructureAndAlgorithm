# 第 14 章 哈希表

- 字母的 int[26]也是一种哈希表。索引对应存储的元素

  - 哈希函数就是 f(cn) = ch - 'a'
  - 但是字符串，浮点数，日期等，哈希函数比较复杂
    - 而且很难保证每一个 key 对应一个不同的索引
    - 解决哈希冲突就是哈希表的根本
  - 充分体现了空间换时间
    - 哈希函数的设计很重要
    - 键和索引分布越均匀越好

- 哈希函数的设计
  - 整型
    - 小范围正整数可以直接使用。负整数进行偏移
    - 大范围整数进行取模，mod。但是取模不好的话会有分布不均匀
      - 具体问题具体分析
      - 取模没有利用所有信息
        - 简单的解决方法是模一个素数。数论
        - [good hash table primes](https://planetmath.org/goodhashtableprimes)
  - 浮点型
    - 浮点型是二进制解析成浮点数而已。转换成整型之后进行哈希即可
  - 字符串
    - 转成整形处理。26 进制的计算也可以。
      - 直接平方其实不一定很快。可以通过每一位乘一次
      - 然后还可以优化成每一次乘之前进行取模就可

```java
int hash = 0
for(int i = 0; i < s.length() ; i++)
  hash = (hash * B + s.charAt(i)) % M
```

- 哈希函数的设计

  - 复合类型
    - 比如日期类。直接转成整型即可
  - 原则
    1. 一致性: a==b 则 hash(a) == hash(b)
    2. 高效性: 计算高效简便
    3. 均匀性: 哈希值均匀分布

- java 的基本类型可以直接调用 hashCode，也很高效

  - java 的整型的 hashcode 就是它本身

- 哈希冲突的处理

  - 链地址法(Separate Chaining)
  - 直接调用 hashCode 整型可能出现负数。需要取绝对值
    - (hashCode(i) & 0x7fffffff) % M
      - 0x7fffffff 是 0 和 31 个 1，所以最高位的符号位一定为 0
    - 0-M-1 的数组
      - 冲突时候制作链表(查找表。不一定要是链表，treeMap 也行)
      - HashMap 就是一个 TreeMap 数组，set 一样
  - Java8 开始，当哈希表冲突达到一定程度，就把每一个位置从链表转成红黑树(TreeMap 的底层)
    - 数据规模比较小的时候链表更快

- 哈希表的实现

  - key 不一定要 comparable
  - 创建对象的数组的时候小心初始化过程！
  - M 的值对性能影响非常大

- 性能分析:

  - 总共 M 个地址, 元素为 N(平均)

    - 底层是链表: O(N/M)
    - 底层是平衡树: O(log(N/M))
    - 不是 O(1)是因为 M 是固定的
    - 所以可以自适应，让 M 尽可能趋近与 N，达到 O(1)级别
    - 底层需要使用动态数组，需要 resize
      - 但是哈希表里面没有元素填满空间的概念
      - 所以需要计算平均每个地址承载的元素过多: N/M
      - 还可以用缩容
      - 尽可能使用乘法，避免除法向浮点型转换的过程
    - 缩容和扩容都要小心 M! 在计算新的 hash 之前需要更新 M!

  - 平均每个操作在 O(lowerTol)~O(upperTol) == O(1)
  - 扩容 M -> 2M，失去了素数性!
    - 扩容方案可以使用素数表
  - 哈希表平均为 O(1)，但是失去了顺序性

- 集合和映射

  - 有序集合,有序映射: TreeSet, TreeMap
  - 无序: HashSet, HashMap

- _面试_

  - equals 的实现(覆盖)方法
    - 传入的是 Object
    - 进行一定的判断
      - 传入是否一样的引用?是否 null?class 是否一致?
      - 判断之后再实现基本逻辑

- 课后学习
  - 哈希冲突攻击
  - 链表转换成红黑树
  - 开放地址法
    - 链地址法: 封闭地址，一个地址只能容纳一种hash
    - 开放地址: 冲突时向之后的索引放(线性探测 +1)
      - 平方探测: +1 +4 +9 +16
      - 二次哈希: hash1 + hash2
      - 空间可能占满。需要看负载率进行resize
      - 只要负载率优化，基本是O(1)
  - 再哈希发
  - Coalesced Hashing
