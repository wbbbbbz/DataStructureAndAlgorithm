# 第 9 章 Trie

- 字典树(Trie)
  - 前缀树
  - 多叉树
  - 专门为了字典设计的树，为了处理字符串
  - 树结构查询是 O(logn)
  - Trie 查询是 O(w),w 是字符串的长度
  - 每个节点有 26 个向下的指针(Node next[26])
    - 还有大小写，符号等等。
    - 所以一般不用静态长度。动态思想
    - Map<char, Node> next;
    - java 是红黑树底层。
  - 在进入子节点之前就已经知道要进入该子节点。所以节点里面不存储 char 也没问题。
  - 因为英语单词是由前缀的，所以叶子节点和是否单词没有直接联系。
    - 此时需要存储一个 Boolean isWord
  - 单词数越多，trie 优势越明显（而且单词长度普遍偏短的话)
  - 前缀搜索
  - Trie 天生有一个 Dummynode,所以递归的时候其实是可以简化的，最终条件可以到达 word.length()

  - 一般不会涉及删除操作。
    - 就看next这个map为不为空
  - 最大问题是空间问题。O(27n)
    - 压缩字典树(Compressed Trie)
      - 维护成本高。需要拆解节点。
      - 单链可以进行折叠
    - Ternary Search Trie(三分搜索树)
      - 以某一个字母为中间，该字母之前，该字母，该字母之后分三个节点
  
  - 后缀树(字符串模式识别)

  - 子串查询
    - KMP
    - Boyer-Moore
    - Rabin-Karp
  - 文件压缩
    - 哈夫曼算法
  - 模式匹配
    - 正则表达式
  - 编译原理
  - DNA

* 课后学习
  - add 的递归写法
  - TrieMap也可以实现。在节点里面加入count。
  - Trie的删除