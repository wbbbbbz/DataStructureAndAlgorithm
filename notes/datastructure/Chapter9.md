# 第 9 章 线段树

- 线段树(Segment Tree)

  - 空间复杂度是 4n

  - 因为要关心线段，区间
  - 区间染色问题
    - 更新区间，查询区间
    - 使用数组实现都是 O(n), O(n)
  - 区间查询
    - 数据如果还在动态变化的话线段树是更适合的数据结构
    - 线段树更新，查询都能 O(logn), O(logn)
    - 区间查询需要节点对应的区间的信息
      - 这个信息可以作为递归函数的参数
      - 也可以新建一个内部类来存储每一个节点对应的区间信息
      - left 和 right 仔细思考可以思考出来。关注于具体决定查询会改变的条件！
  - 一般线段树不考虑添加和删除。区间本身固定。
    - 一棵树，每一个节点表示一段区间相应的信息，到最底层是每一个元素的相应信息
    - 比如求和，根节点储存完整区间的和。然后平均分成两段，每一段再细分，每一个节点都储存信息
  - 不一定是满二叉树，也不一定是完全二叉树，但是一定是平衡二叉树
    - 最大深度和最小深度相差为 1
    - 完全二叉树一定是平衡二叉树
    - 平衡二叉树搜索很方便
  - 线段树可以看作是一个满二叉树，使用数组表示。不存在的地方当作空即可
  - 满二叉树是 2 的等比数列。
    - 如果 n=2^k，刚好满足最下面一层的叶子节点，那么所需空间为 2n（实际上是 2n-1,非叶子节点总和=叶子节点总和-1）
    - 最坏情况：如果 n=2^k+1，那么还需要多一层。下一层大概是 2n，所以整体需要 4n。
    - 所以一开始静态直接赋予 4n 即可
    - 空间换时间
  - 线段树中不需要找父节点！
  - 创建树的时候是典型递归！
  - 区间更新
    - 其实跟区间查询基本一样，而且更简单！
  - 查询，更新之后需要进行融合操作，其实本质上是树的后序遍历

- 基本是竞赛使用。

- 课后学习
  - 区间更新
    - 懒惰更新。因为区间更新需要更新所有叶子节点，等同于O(n)。可以先进行更新非叶子节点。
    - 可以使用记录一个lazy数组，记录了哪一些节点没有更新。下一次进行查询或者更新的时候可以查询lazy数组，如果有记录就先进行更新。
  - 二叉索引树(竞赛)
    - [二叉索引树 （英语：Binary Indexed Tree）\_dpwang-CSDN 博客](https://blog.csdn.net/dpengwang/article/details/100838147)
    - [原码、反码、补码知识详细讲解（此作者是我找到的讲的最细最明白的一个）\_网络\_Coding-CSDN 博客](https://blog.csdn.net/zl10086111/article/details/80907428)
    - [Java using Binary Indexed Tree with clear explanation - LeetCode Discuss](https://leetcode.com/problems/range-sum-query-mutable/discuss/75753/Java-using-Binary-Indexed-Tree-with-clear-explanation)
  - 二维线段树
    - 可以记录矩阵内容。矩阵分成4块，左上右上左下右下。
    - 三维线段树也是可以的。
  - 链式动态线段树
    - 懒惰型创建
  - RMQ(Ranged Minimum Query)，区间经典问题
