# 第 12 章 AVL

- 二叉树的问题在于容易不平衡
- AVL 是名字缩写。
  - 最早的自平衡树结构
- 平衡二叉树：

  - 任意一个节点的左子树和右子树的高度差不能超过 1
    - 比堆和线段树宽松
    - 高度和节点数量是满足 O(logn)
  - 需要记录每一个节点的高度！叶子节点为 1
    - 非叶子节点求最大子树高度+1
  - 平衡因子：左右子树高度差
    - 平衡因子绝对值大于等于 2 就不是 AVL 树了
  - 每次 add 节点的时候维护 height

- 除了是一个 AVL 树之外，也必须保证是一个二分搜索树
  - 所以在再平衡 AVL 树的时候也要保证是一个二分搜索书
  - 加入 boolean isBST()
- 虽然每个节点记录了高度，但是这个只看一个节点的左右节点无法判断是否平衡！

  - 高度是最大深度，但是平衡时每一个节点都要进行判断的，子树不平衡但是整体平衡很有可能！

- 自平衡

  - 维护平衡的时机
    - 加入节点后，沿着节点向上维护平衡性
    - 只有加入节点才可能破坏平衡
    - 可能破坏的只有沿路的节点
    - 因为添加是递归的，所以沿路维护也非常容易
  - 右旋转：
    - y 的左子树是 x。现在树向左倾斜时(left - right > 1 && left >= 0)
      - 此时令 temp = x.right, x.right = y, y.left = temp. x 也需要一个指针.
      - 图像上就是 x 的父节点进行了顺时针(右方向)的旋转
      - 此时新的树既满足二分搜索树，也满足二叉平衡树
      - 因为 x 和 x 的子树都保持了平衡性。
      - 因为维护是在添加节点的时候完成的。添加节点的时候需要维护的节点平衡度为 2，也就是
        x 的高度和 y 的右子树高度之间差距为 2。
      - [AVL 树的旋转图解和简单实现 - 简书](https://www.jianshu.com/p/6988699625d5)
      - 旋转要维护高度！
  - 左旋转类似。对称
  - 不平衡在左侧的右侧或者右侧的左侧比较麻烦
    - LR 的情况
      - 先对 left 进行左旋转(转化为 LL)，然后再对当前节点进行右旋转
    - RL 对称
  - BST 的话在退化成链表的时候性能会低下

  - 删除要素和添加元素的维护方式时一摸一样的！
    - 之前 BST 的 remove 中调用了 removeMin, 这个函数有可能打破平衡，所以应该进行维护
    - 如果麻烦的话可以将 removeMin 改成调用 remove，同样使用删除函数，remove 内进行维护即可
  - 维护步骤
    - if null return null
    - 更新高度
    - 计算平衡因子
    - 进行相应旋转维护并更新高度
    - 返回节点


    | 插入方式        | 描述    |  旋转方式  |
    | --------   | -----:   | :----: |
    | LL        | 插入左子树的左子树(left - right > 1 && leftBalanceFactor >= 0)      |   右旋转    |
    | RR        | 插入右子树的右子树(right - left > 1 && rightBalanceFactor <= 0)      |   左旋转    |
    | LR        | 插入左子树的右子树(left - right > 1 && leftBalanceFactor < 0)      |   左旋转后右旋转    |
    | RL        | 插入右子树的左子树(right - left > 1 && rightBalanceFactor > 0)      |   右旋转后左旋转     |

- 平均来说红黑树比AVL树更优
  - 因为旋转操作数更少

- 课后学习
  - AVL树的set和map
  - AVL树的细微优化
    - 每一次增加或者删除需要计算高度，如果高度和原先高度一样，那么该节点和祖先节点都不需要进行平衡维护
