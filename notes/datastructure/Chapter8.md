# 第 8 章 优先队列和堆

- 需要比较的数据结构（二叉树，堆等等）都需要 extends Comparable
- 接下来四章都是树的应用
  - 树这种数据结构非常广泛，就是因为只要对数进行一些限制，就可以做出新数据结构
- 优先队列
  - 区别在于出队！
  - 关键是动态。如果是静态那就直接排序即可
  - 因为是动态，（会不断来新的任务）
  - 接口和 queue 一样。只不过出队和队首需要不一样的逻辑！
  - 因为出队需要判断最优先的元素，那么使用有顺序的结构比较好！
  - 线性结构：
    - 普通线性结构：入队 O(1)，出队(拿出最大元素)O(n)
    - 顺序线性结构: 入队 O(1), 出队 O(1)
  - 堆：入出队都是 O(logn)
- 一般来说计算机领域里面出现 logn 可能就是树。就算排序算法里面没有使用树，但是递归里面使用了隐形的树。
- 二叉堆

  - 完全二叉树（节点一定是从左到右存放的！）不是满二叉树！因为元素量不一定满。
  - 堆中某个节点的值总是不大于其父节点（最大堆），当然还有最小堆
  - 但是大小和层次之间没有关系！
  - 因为堆是一个完全二叉树，元素是按顺序排列的，所以底层可以使用数组进行存放
  - parent(i) = i/2，left child(i) = 2\*i, right child(i) = 2\*i +1 (从 1 开始标)
  - parent(i) = (i - 1)/2，left child(i) = 2\*i + 1, right child(i) = 2\*i +2 (从 0 开始标)
  - sift up（上浮）
    - add 的时候，先直接添加到末尾
    - 然后不满足堆的性质的话，就进行 sift up
    - 与父节点进行比较，大的话就交换
  - 取出最大值(Extract Max)
    - 取出最大值（root）之后，将最后一个元素放至堆顶
    - sift down(下沉)
    - 与两个孩子比较，和比较大的进行交换
    - _小心-1/2=0_
  - 因为是一个完全二叉树，所以一定不会退化成链表！

- Replace
  - 取出最大元素后，放入一个新元素
    - 如果 extractMax->add 两次 O(logn)
    - 直接将堆顶替换之后 sift Down，一次 O(logn)

* 课后学习
  - 堆原地排序算法
  - 如何打印成树？
  - 广度优先遍历递归？
