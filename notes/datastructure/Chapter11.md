# 第 11 章 并查集

- 并查集(Union Find)(并集，查询)

  - 孩子指向父亲。一种很不一样的树形结构
  - 可以高效解决连接问题(Connectivity Problem)
    - 给出图中任意两点，是否连接？
  - 可以非常快的判断网络(抽象)中节点间的连接状态
  - 数学中的集合类的实现(特别是经常使用的是求并集)
  - 连接问题比路径问题要回答的问题少很多，所以用路径解答的话效率低。
    - 堆和顺序表的比较
  - union(p, q), isConnected(p, q)
    - p, q 实际上不需要是元素本身。在判断是否连接的时候只要知道索引就行，内容不关心。
    - 不考虑添加删除
  - 基本数据可以用编号表示。
    - 每一个编号存储的是所属集合的 id。不同的 id 就是不同的集合。
  - 连接：直接看 find(p) == find(q)。就是看是否一个集合
    - find 时间复杂度 O(1),QuickFind
  - 初始化的时候令所有元素的集合 id 不相等，那就意味着不是一个集合里的。
  - 并集：两个集合并集的时候，集合内所有元素的集合编号都要更新成同一个编号。

    - Quick Find 下的 Union 时间 O(n)，需要遍历修改编号(数组模拟)

  - 但是一般都是使用 quick union。

    - 每一个元素看作一个节点。
    - 同一组的元素指向同一个根节点，该根节点指向自己
      - 如果并集的时候，集合的根节点指向别的集合的根节点即可
    - 每一个元素只有一个指针，指向 parent。
      - 所以可以通过数组进行实现
    - 初始状态是一个森林，所有元素指向自己。
      - 4 指向 3 就是 parent[4] = 3
      - 3 指向 8 就是 parent[3] = 8
      - 9 指向 4 就要查询 9--4--3--8--8，所以指向 8
      - 如果 9 指向 4 的话就会退化成链表，树的优势就不存在了
    - union 一般是 O(h),h 是树的高度
    - 查询也是 O(h),查询根节点是否一致
    - 严格意义上说查询和并集都是 O(log\*n)，iterated logarithm
      - log 的递归计算。
      - 近乎 O(1)，非常快。

  - java 底层对连续地址访问优化的很好，而 quickunion 那种不连续访问优化效果就会差一点

  - quickunion 如果不对树的形状不进行判断，那么很有可能退化成链表！

    - 应该对 size 进行考虑。size 小的树指向 size 大的树！
    - 这种优化思想是尽可能使树的深度变小

  - 基于 rank 的优化(rank 就是深度)

    - size 小的树不一定深度小。所以应该记录树的深度
    - rank 的维护其实很简单。只有当合并前后两棵树大小一样的时候，才有可能要进行维护！
      - 当两棵树大小相差 1 的时候，并集后最大深度保持不变

* 路径压缩

  - 同样表示一种集合，但是树的表示方式可能不同。
  - 深度越小(也就是所有数据直接指向根节点)的树效率更好
  - 只要能压缩一部分就行
  - 在 find 中进行压缩即可。因为 find 本身就要进行遍历，顺便压缩就好。
  - parent[p] = parent[parent[p]]。一行代码即可。一般都要加入这个优化
  - 实际路径压缩之后不维护 rank 是没有问题的

    - 因为 rank 实际不是指树的深度，而是排序的序。
    - rank 整体大小关系还是不变。
    - 如果 rank 都进行维护了性能消耗也很大！

  - 当然直接压缩成 2 层树也行，通过递归压缩即可
    - parent[p] = find(parent[p])
    - find 就是返回根节点
    - 如果现在 p 索引的父节点不是根节点，那就让父节点等于父节点的根节点即可
    - 递归还是有一定开销！
    - 就算不进行递归，多进行几次普通路径压缩也会压缩到最小！
