# 第 6 章 二分搜索树

- 树结构简介：
  - 天然的组织结构（文件列表，图书分类，组织架构）
  - 树结构高效，有时候数据使用树结构存储后非常高效
  - **面试重点**
- 二叉树就是两个叉，还有 26 叉数
- 二叉树具有天然递归结构
  - 每个节点的左右子树都是二叉树！
- 二叉搜索树
  - 大于所有左子树
  - 小于所有右子树
  - 不包含重复元素。如果需要包含重复的话需要将上面改成小于等于，大于等于
  - 存储的数据必须有可比较性(BinarySearchTree<E extends Comparable<E>>)
  - 继承了 Comparable 的泛型也不能直接使用<>号。必须使用 equals, compareTo
  - 插入 -注意插入需要维护 size！
- 高层数据结构(比如集合 set 和映射 map)
  - 设计的时候这种高层数据结构通常使用接口定义方法
  - 然后通过底层数据结构进行实现（这个可以随便选）
- 集合
  - 集合不能存放重复元素，所以二分搜索树是一个很好的实现“集合”的底层数据结构
- 遍历
  - 前序：节点->左子树->右子树。最常用，最自然。
  - 中序：左子树->节点->右子树。结果是排序的。因为是先小后大
  - 后序：左子树->右子树->节点。先孩子后父。释放内存。
  - 快速分析: 每一个节点画三个小点（左子树，右子树，自己）。每一个节点都要经过三次，具体看哪一次输出，就在该点被 call 的时候输出即可！
  - 遍历的非递归写法。通过模拟系统栈即可！
    - 可以先压右子树，再压左子树从而达成出栈的时候先左后右
    - 既可以在出栈的时候判断是否为 null，也可以在压栈的时候不压 null
    - 参考:二叉树的非递归前序、中序、后序遍历算法详解及代码实现（C 语言）\_C/C++\_Benja_K 的博客-CSDN 博客https://blog.csdn.net/Benja_K/article/details/88389039
  - 广度优先遍历更有利于搜索。无权图的最短路径。
  - 图算法也有广度和深度优先。因为图的父节点可能是复数的，所以需要记录是否已经访问，以避免重复访问。
- 删除

  - 二分树删除比较复杂。涉及到树的重构
  - 先从寻找最大最小值->删除最大最小值->删除一般值
    - 删除的时候递归可以返回删除节点后新的二分搜索树的根。
    - 删除只有左子树，只有右子树的都不麻烦，直接用子树代替本身即可（叶子节点也可以这么理解）
    - 删除左右都有孩子节点的时候，需要在右子树中找出后继，然后把后继删除，取出，连接到现有的左右节点，然后返回即可
    - d = find() -> s = min(d.right) -> s.right = delMin(d.right) -> s.left = d.left
      - 上面的 min 和 delMin 两个的宏观意义不一样
      - min 返回的就是最小节点
      - 而 delMin 返回的是删除完 min 之后的根节点
  - 删除需要借用的方法：remove(E e), remove(Node node, E e), removeMin(Node node), getMinimumNode(Node node)
    不递归的话没办法把节点连到父节点上？
    - 前驱或者后继都是可以的！

- 二分搜索树有序。所以可以有下列操作：

  - minimum, maximum
  - successor, predecessor
  - floor, ceil（找某一个元素的比它小的最大和比它大的最小）
  - rank, select（排名和排名对应的元素）
  - 维护每一个节点的 size!（这样的话 rank 和 select 会很简单！）
  - 还可以维护一个 depth！
  - 重复元素可以维护一个 count！

- 本章中的树递归很多都是先设计用户用的方法，然后通过 private 方法，返回 node 进行递归处理。这个方法返回的 node 是让父节点进行连接的！所以最后要 root = xxx();
- 删除结点每次都要想想 size 的维护和原有 node 的 null（断连接！）

- 课后学习
  - 非递归的所有实现（遍历）
  - 如何打印成树？
  - 广度优先遍历递归？
